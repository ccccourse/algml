### 對偶理論（Duality Theory）

**概念解釋：**

對偶理論是優化領域中的一個非常重要的理論框架。它通過將原始（primal）優化問題轉化為對偶（dual）優化問題，提供了一種新的解決問題的方法。在某些情況下，解決對偶問題比直接解原始問題更為高效。

**對偶理論的核心思想**：
- **原始問題（Primal Problem）**：通常是我們想要解決的問題。
- **對偶問題（Dual Problem）**：由原始問題推導出來的問題，它是一個與原始問題相關聯的優化問題，通過對偶理論，我們可以將其轉換為一個可解決的問題。

對偶問題通常比原始問題更簡單，並且對偶問題的解提供了原始問題解的下界或上界。這樣的關係稱為**對偶性**。

**數學表示**：
假設我們有一個優化問題：

原始問題（Primal）：
\[
\min_{x} f(x) \quad \text{subject to} \quad g_i(x) \leq 0, \quad h_j(x) = 0
\]

對偶問題（Dual）：
\[
\max_{\lambda, \nu} L(x, \lambda, \nu)
\]
其中，\(L(x, \lambda, \nu)\) 是拉格朗日對偶函數，\( \lambda \) 和 \( \nu \) 是拉格朗日乘數。

**對偶理論的主要定理**：
1. **弱對偶性**：對偶問題的解是原始問題解的下界（如果是最小化問題），即對偶問題的最優解總是大於或等於原始問題的最優解。
2. **強對偶性**：在某些條件下，原始問題的最優解和對偶問題的最優解是相等的，這種情況稱為強對偶性，通常當原始問題的約束條件是凸的時，會出現這種情況。

**拉格朗日對偶性**：
拉格朗日對偶性主要基於將約束條件（尤其是不等式約束）引入拉格朗日函數中，然後轉化為對偶問題。

**拉格朗日對偶函數**：
對於原始問題：
\[
\min_x f(x)
\]
\[
\text{subject to } g_i(x) \leq 0
\]
我們定義拉格朗日函數：
\[
L(x, \lambda) = f(x) + \sum_{i=1}^m \lambda_i g_i(x)
\]
其中，\( \lambda_i \) 是對應於每個不等式約束 \( g_i(x) \) 的拉格朗日乘數。

對偶問題是最大化對偶函數：
\[
\max_{\lambda \geq 0} \min_x L(x, \lambda)
\]
對偶理論的關鍵在於求解這個對偶問題，並根據對偶問題的解推導出原始問題的解。

### Python 範例：對偶問題求解

以下是使用 **SciPy** 來解決帶有簡單約束的最小化問題，並且進行對偶求解的範例。此範例演示如何基於對偶理論將原始問題和對偶問題進行求解。

#### 例子設定：
最小化目標函數 \( f(x) = x_1^2 + x_2^2 \)，並滿足不等式約束 \( x_1 + x_2 \leq 1 \) 和 \( x_1 \geq 0 \)。

1. **原始問題**：
   \[
   \min_{x_1, x_2} f(x_1, x_2) = x_1^2 + x_2^2
   \]
   \[
   \text{subject to } x_1 + x_2 \leq 1, \quad x_1 \geq 0
   \]

2. **對偶問題**：
   使用拉格朗日對偶方法將約束引入拉格朗日函數進行求解。

#### Python 實現：

```python
import numpy as np
from scipy.optimize import minimize

# 定義原始問題的目標函數
def objective(x):
    return x[0]**2 + x[1]**2

# 定義不等式約束條件
def constraint1(x):
    return 1 - (x[0] + x[1])  # x1 + x2 <= 1

def constraint2(x):
    return x[0]  # x1 >= 0

# 初始猜測值
x0 = [0.5, 0.5]

# 設置不等式約束
constraints = [{'type': 'ineq', 'fun': constraint1},
               {'type': 'ineq', 'fun': constraint2}]

# 使用SciPy的minimize函數進行優化
solution = minimize(objective, x0, constraints=constraints)

# 顯示最優解
print("最優解:", solution.x)
print("目標函數值:", solution.fun)
```

**程式解析**：
1. `objective(x)`：定義了原始問題的目標函數 \( f(x_1, x_2) = x_1^2 + x_2^2 \)。
2. `constraint1(x)` 和 `constraint2(x)`：分別定義了不等式約束 \( x_1 + x_2 \leq 1 \) 和 \( x_1 \geq 0 \)。
3. `minimize()`：使用 `scipy.optimize.minimize` 函數解決優化問題，設置不等式約束條件。
4. 輸出最優解和目標函數值。

**結果**：
- 該程式會顯示出符合約束條件的最小化解，並計算對應的目標函數值。

### 結論：
對偶理論是一個非常強大的工具，能夠幫助我們從不同的角度來看待和解決優化問題。在實際應用中，對偶問題可能更加容易求解，並且能夠提供原始問題解的上下界或進一步的問題分析。