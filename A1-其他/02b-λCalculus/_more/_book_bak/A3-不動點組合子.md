## 不動點組合子

不動點組合子（Fixed-point Combinator）是一種高階函數，專門用來計算函數的固定點。固定點是指對於某個函數 \( f \)，當我們將某個值 \( x \) 代入該函數時，結果仍然是 \( x \) 本身，換句話說，\( f(x) = x \)。例如，對於函數 \( f(x) = x^2 \)，0 和 1 都是其固定點，因為 \( 0^2 = 0 \) 和 \( 1^2 = 1 \)。

對於高階函數來說，不動點組合子的作用更為深刻，它能計算出使得 \( f(g) = g \) 的函數 \( g \)，其中 \( g \) 是函數 \( f \) 的不動點。這種函數不動點的概念，常見於函數式編程語言中，其中最著名的例子就是Y組合子。

### Y組合子

Y組合子是最常見的不動點組合子之一，由Haskell B. Curry發現，定義為：

\[
Y = \lambda f. (\lambda x. f(x \, x)) (\lambda x. f(x \, x))
\]

這個定義使得Y組合子能夠實現遞歸。透過Y組合子，匿名函數可以達到類似遞歸的效果，即便在沒有明確遞歸結構的情況下也能實現循環的效果。當Y組合子應用於帶有一個變量的函數時，可能會導致無限循環，這使得它在傳值求值策略下不會終止。

### 不動點組合子的數學性質

在數學的某些形式化系統中，如無類型的lambda演算和組合演算中，所有表達式均視為高階函數。在這些系統中，不動點組合子的存在性意味着「所有函數至少有一個不動點」，並且這些函數可能有多個不動點。然而，在一些有類型的lambda演算中，由於類型系統的限制，無法為所有函數寫出不動點組合子。這些系統需要額外的語言擴展來顯示支持遞歸的特性。

### 範例

例如，若想要定義階乘函數，可以使用不動點組合子來表達遞歸過程：

定義階乘函數的遞歸步驟如下：

\[
\text{fact}(n) = \text{if } n = 0 \text{ then } 1 \text{ else } n \times \text{fact}(n-1)
\]

將此遞歸過程轉換為lambda演算後，使用不動點組合子來實現遞歸求值：

\[
\text{fact} = \text{fix}(F)
\]

這裡的 \( F \) 是一個遞歸步驟函數，通過不動點算子 \( \text{fix}(F) \) 我們就能夠得到完整的階乘遞歸函數。

### 其他不動點組合子

除了Y組合子，還有其他不動點組合子的變體。例如，Z組合子是在Y組合子的基礎上進行部分η展開後得到的：

\[
Z = \lambda f. (\lambda x. f(\lambda y. x \, x \, y)) (\lambda x. f(\lambda y. x \, x \, y))
\]

此外，還有圖靈不動點組合子，它由阿蘭·圖靈發現，並且具有一個簡單的傳值調用形式：

\[
\Theta = (\lambda x. \lambda y. (y (x \, x \, y))) (\lambda x. \lambda y. (y (x \, x \, y)))
\]

### 總結

不動點組合子是一個強大的工具，它允許我們在函數式編程中以非遞歸的方式實現遞歸。Y組合子是最著名的不動點組合子，它為無遞歸函數提供了遞歸能力，而其他變體則展示了不同的實現方式。通過這些組合子，我們能夠在不同的語言和數學系統中深入探討遞歸和不動點的概念。