## 系統F

系統F，也叫做多態Lambda演算或二階Lambda演算，是一種擁有類型的Lambda演算。它由邏輯學家Jean-Yves Girard與計算機科學家John C. Reynolds獨立發現。系統F形式化了程式語言中參數多態的概念，並作為Lambda演算的擴展，允許類型變量的引入。

在Lambda演算中，變量的取值範圍是函數，而系統F中，取值範圍變為類型。系統F的核心思想是支持以類型為參數的泛型函數。這使得系統F成為描述具有多態性的函數的有力工具。

#### 恆等函數範例

在系統F中，恆等函數 `λx. x` 可以表示為 `∀α. α → α`，這裡的 `α` 是一個類型變量。具體地，可以寫作：

```
⊢ Λα. λx^α. x : ∀α. α → α
```

這表明，恆等函數接受一個類型 `α` 並返回該類型的值，無論 `α` 是什麼類型。

#### Curry-Howard同構

在Curry-Howard同構下，系統F對應於二階邏輯。這意味著系統F中的類型系統與邏輯中的命題結構有著對應關係，進一步強化了Lambda演算在邏輯推理中的應用。

### 布爾邏輯在系統F中的表現

在系統F中，布爾類型可以表示為 `∀α. α → α → α`，這樣的類型描述了接受兩個相同類型的參數並返回一個相同類型的結果的函數。可以用這些型別來定義布爾值及邏輯運算：

- **TRUE** 和 **FALSE** 的定義如下：

  ```
  TRUE := Λα. λx^α. λy^α. x
  FALSE := Λα. λx^α. λy^α. y
  ```

  這表示布爾值 `TRUE` 會選擇第一個參數，而 `FALSE` 會選擇第二個參數。

- 基於這些布爾類型，可以定義常見的邏輯運算：

  - **AND**:
    ```
    AND := λx^Boolean λy^Boolean. ((x(Boolean)) y) FALSE
    ```

  - **OR**:
    ```
    OR := λx^Boolean λy^Boolean. ((x(Boolean)) TRUE) y
    ```

  - **NOT**:
    ```
    NOT := λx^Boolean. ((x(Boolean)) FALSE) TRUE
    ```

  - **IFTHENELSE**（如果需要的話）:
    ```
    IFTHENELSE := Λα. λx^Boolean λy^α λz^α. ((x(α)) y) z
    ```

### 謂詞和邱奇數

系統F中還能夠定義謂詞，這些謂詞返回布爾值。例如，`ISZERO` 謂詞判斷一個數是否為零：

```
ISZERO := λn. n (λx. FALSE) TRUE
```

這個謂詞會檢查 `n` 是否為零。如果是零，它返回 `TRUE`，否則返回 `FALSE`。

### 遞歸與自然數

系統F允許以自然的方式表達遞歸。透過構造子，我們可以定義帶有遞歸結構的函數。例如，系統F中的自然數可以通過以下遞歸結構來定義：

- **零** (`zero`):
  ```
  zero := Λα. λx^α. λf^(α → α). x
  ```

- **後繼** (`succ`):
  ```
  succ := Λα. λx^α. λf^(α → α). f x
  ```

在這裡，`zero` 是表示數字零的項，`succ` 是表示自然數後繼的函數。這樣的結構可以進一步表示具體的自然數，如：

- **1**:
  ```
  1 := Λα. λx^α. λf^(α → α). f x
  ```

- **2**:
  ```
  2 := Λα. λx^α. λf^(α → α). f (f x)
  ```

這些自然數的定義是一系列高階函數，接受一個函數作為參數，並將其應用到一個初始值上，從而構造出數字。

### 系統F與程式語言

本文所介紹的系統F版本是顯式類型的，這使得類型檢查變得簡單直接。類型信息的明確性使得系統F特別適合用於程式語言的設計與分析。儘管系統F是可表達性很強的，但它的類型推理是不可判定的，這意味著無法在一般情況下自動推斷程序的類型。

因此，某些程式語言如Haskell和ML基於系統F的簡化版本（Hindley-Milner系統）進行類型推理，並能夠提供類型推斷功能，儘管它們的推斷範圍有所限制。

### 總結

系統F是Lambda演算的強大擴展，它支持類型變量並允許多態性。它可以表達多數數學結構，並為高階編程語言提供理論基礎。系統F的引入改進了我們對類型的理解，並對程式語言的設計產生了深遠的影響。