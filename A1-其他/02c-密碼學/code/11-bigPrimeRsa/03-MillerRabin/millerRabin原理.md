
## ccc: 請說明何謂 米勒-拉賓質數判定法

ChatGPT: https://chatgpt.com/c/674bd8c0-7eac-8012-86c3-416ad163e18b

米勒-拉賓質數判定法（Miller-Rabin Primality Test）是一種概率型的質數判定算法，它用來判斷一個數字是否為質數。與一般的質數測試（例如試除法）不同，米勒-拉賓算法是一種基於隨機化的測試，因此其結果並非總是確定的，但可以提供極高的準確度，尤其是當進行多次測試時。

### 基本原理
米勒-拉賓質數判定法基於數論中的**費馬小定理**，該定理指出：如果 \( p \) 是質數，對於任何整數 \( a \)，有 \( a^{p-1} \equiv 1 \pmod{p} \)。不過，這個定理並非對所有數字有效，當 \( p \) 不是質數時，有些數字 \( a \) 會違反這個關係。米勒-拉賓算法利用這一特性來判定一個數字是否為質數。

### 主要步驟
1. **寫成特定形式**：
   對於給定的整數 \( n \)（待測的數字），將其寫成以下形式：
   \[
   n-1 = 2^s \cdot d
   \]
   其中 \( d \) 是奇數，\( s \) 是一個非負整數。

2. **選擇隨機基數**：
   隨機選擇一個整數 \( a \)，其中 \( 1 \leq a \leq n-1 \)。

3. **計算**：
   計算 \( a^d \mod n \)。如果結果是 1 或 \( n-1 \)，則可以認為這次測試沒有證明 \( n \) 不是質數，繼續進行其他測試。

4. **迭代檢查**：
   如果 \( a^d \mod n \neq 1 \) 且 \( a^{2^r \cdot d} \mod n \neq n-1 \)（對於所有 \( r = 0, 1, \dots, s-1 \)），則 \( n \) 不是質數，反之則是質數的候選者。

### 優勢與局限
- **優勢**：
  - 米勒-拉賓算法可以快速檢測大數是否為質數，且對於較大的數字比其他傳統方法（如試除法）更有效。
  - 它是概率型的，即使是大數，也能在合理的時間內給出質數判定結果。

- **局限**：
  - 米勒-拉賓質數判定法是一個**概率性**算法，並非百分之百準確。多次測試可以大大降低出錯的機會，但仍然存在極低的錯誤概率。
  - 若選擇的基數 \( a \) 不合適，可能會出現誤判的情況。

### 改進：
通常會進行多次測試來提高準確度。如果每次測試選擇的基數不同，則錯誤的概率會極低，對於大多數實際應用來說，這樣的概率可以忽略不計。

總結來說，米勒-拉賓質數判定法是一種高效且常用的質數判定算法，適合用於大數的質數檢測，尤其是在需要快速運算的場合。

## ccc: 請用 python 寫一個米勒-拉賓質數判定程式

以下是用 Python 實現的米勒-拉賓質數判定法：

```python
import random

# 計算 a^b % n 的快速冪
def power_mod(a, b, n):
    result = 1
    a = a % n
    while b > 0:
        if b % 2 == 1:
            result = (result * a) % n
        a = (a * a) % n
        b //= 2
    return result

# 米勒-拉賓質數判定法
def miller_rabin(n, k=5):
    # 特殊情況：1 不是質數，2 和 3 是質數
    if n <= 1:
        return False
    if n <= 3:
        return True
    if n % 2 == 0 or n % 3 == 0:
        return False

    # 寫成 n-1 = 2^s * d 的形式
    d = n - 1
    s = 0
    while d % 2 == 0:
        d //= 2
        s += 1

    # 進行 k 次隨機測試
    for _ in range(k):
        # 隨機選擇 a，1 <= a <= n-1
        a = random.randint(2, n - 2)
        # 計算 a^d % n
        x = power_mod(a, d, n)
        if x == 1 or x == n - 1:
            continue
        
        # 檢查是否存在 a^(2^r * d) % n == n-1
        for _ in range(s - 1):
            x = power_mod(x, 2, n)
            if x == n - 1:
                break
        else:
            return False

    # 如果經過多次測試都沒有找到錯誤，則 n 很可能是質數
    return True

# 測試
if __name__ == "__main__":
    test_numbers = [11, 15, 23, 33, 97, 100, 101]
    for num in test_numbers:
        result = miller_rabin(num)
        print(f"{num} is {'prime' if result else 'not prime'}")
```

### 程式說明：
1. `power_mod(a, b, n)` 是計算 \(a^b \mod n\) 的快速冪算法，這樣可以有效計算大數的模運算。
2. `miller_rabin(n, k=5)` 是米勒-拉賓質數判定算法：
   - 首先處理特殊情況，對 1、2、3 和偶數進行簡單的質數檢查。
   - 接著將 \(n-1\) 表示為 \(2^s \cdot d\) 的形式，並進行 \(k\) 次隨機測試。
   - 每次測試中，隨機選擇一個基數 \(a\)，並進行一系列的模指數運算來判斷 \(n\) 是否是質數。
3. 測試部分會對多個數字進行判定，並輸出是否為質數。

### 輸出範例：
```
11 is prime
15 is not prime
23 is prime
33 is not prime
97 is prime
100 is not prime
101 is prime
```

### 說明：
- `k=5` 表示測試會進行 5 次隨機選擇基數進行測試，這個次數越多，判定的準確度越高。


